import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { supabase } from '@/lib/supabase';
import Header from '@/components/Header';
import Footer from '@/components/Footer';

interface Question {
  id: string;
  text: string;
  type: 'radio' | 'checkbox';
  options: string[];
}

const fetchOrderIndex = async (
  identifier: string,
  table: string,
  column: string = 'slug' // Default to 'slug', but allow overriding
): Promise<number | null> => {
  const { data, error } = await supabase
    .from(table)
    .select('order_index')
    .eq(column, identifier)
    .single();

  if (error) {
    console.error(`Error fetching order_index from ${table}:`, error);
    return null;
  }

  return data?.order_index || null;
};

const fetchSubjectId = async (slug: string): Promise<string | null> => {
  const { data, error } = await supabase
    .from('subjects')
    .select('id')
    .eq('slug', slug)
    .single();

  if (error) {
    console.error('Error fetching subject id:', error);
    return null;
  }

  return data?.id || null;
};

const fetchOrderIndexForChapter = async (
  subjectSlug: string,
  title: string,
  form: number
): Promise<number | null> => {
  const subjectId = await fetchSubjectId(subjectSlug);
  if (!subjectId) {
    console.error('Subject ID not found for slug:', subjectSlug);
    return null;
  }

  const { data, error } = await supabase
    .from('chapters')
    .select('order_index')
    .eq('subject_id', subjectId)
    .eq('title', title)
    .eq('form', form) // Include form to uniquely identify the chapter
    .single();

  if (error) {
    console.error('Error fetching order_index from chapters:', error);
    return null;
  }

  return data?.order_index || null;
};

export default function CreateQuiz() {
  const router = useRouter();
  const { subject, topic, chapter } = router.query;
  const [quizTitle, setQuizTitle] = useState('');
  const [questions, setQuestions] = useState<Question[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [userId, setUserId] = useState<string | null>(null);

  useEffect(() => {
    console.log('Query parameters:', { subject, topic, chapter });
  }, [subject, topic, chapter]);

  useEffect(() => {
    const generateTitle = async () => {
      if (subject && topic && chapter) {
        const subjectOrderIndex = await fetchOrderIndex(
          subject as string,
          'subjects'
        );
        const chapterOrderIndex = await fetchOrderIndexForChapter(
          subject as string,
          chapter as string,
          4
        ); // Pass form as an additional parameter
        const topicOrderIndex = await fetchOrderIndex(
          topic as string,
          'topics',
          'id'
        ); // Use 'id' for topics

        if (
          subjectOrderIndex !== null &&
          chapterOrderIndex !== null &&
          topicOrderIndex !== null
        ) {
          const randomCode = Math.random()
            .toString(36)
            .substring(2, 6)
            .toUpperCase();
          const autoGeneratedTitle = `${subjectOrderIndex.toString().padStart(2, '0')}${'01'}${chapterOrderIndex.toString().padStart(2, '0')}${topicOrderIndex.toString().padStart(2, '0')}${randomCode}`;
          setQuizTitle(autoGeneratedTitle);
        }
      }
    };

    generateTitle();
  }, [subject, topic, chapter]);

  useEffect(() => {
    const fetchUserId = async () => {
      const {
        data: { session },
        error,
      } = await supabase.auth.getSession();

      if (error) {
        console.error('Error fetching session:', error);
        return;
      }

      if (session?.user?.id) {
        setUserId(session.user.id);
      }
    };

    fetchUserId();
  }, []);

  const addQuestion = () => {
    setQuestions([
      ...questions,
      { id: `${questions.length + 1}`, text: '', type: 'radio', options: [] },
    ]);
  };

  const deleteQuestion = (id: string) => {
    setQuestions(questions.filter((q) => q.id !== id));
  };

  const handleQuestionChange = (
    id: string,
    updatedQuestion: Partial<Question>
  ) => {
    setQuestions((prev) =>
      prev.map((q) => (q.id === id ? { ...q, ...updatedQuestion } : q))
    );
  };

  const handleAddOption = (id: string) => {
    setQuestions((prev) =>
      prev.map((q) => (q.id === id ? { ...q, options: [...q.options, ''] } : q))
    );
  };

  const handleOptionChange = (
    id: string,
    optionIndex: number,
    value: string
  ) => {
    setQuestions((prev) =>
      prev.map((q) =>
        q.id === id
          ? {
              ...q,
              options: q.options.map((opt, idx) =>
                idx === optionIndex ? value : opt
              ),
            }
          : q
      )
    );
  };

  const handleCreateQuiz = async () => {
    if (!quizTitle) {
      alert('Please enter a quiz title.');
      return;
    }

    if (questions.length === 0) {
      alert('Please add at least one question.');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const { error } = await supabase.from('quizzes').insert({
        name: quizTitle,
        topic_id: topic,
        created_by: userId, // Use session's user ID
        questions,
      });

      if (error) {
        throw error;
      }

      alert('Quiz created successfully!');
      router.push(`/quiz/${subject}/${topic}`);
    } catch (err) {
      console.error('Error creating quiz:', err);
      setError('An error occurred while creating the quiz.');
    } finally {
      setLoading(false);
    }
  };

  const handleSaveQuestionsAndAnswers = async () => {
    if (!quizTitle) {
      alert('Please enter a quiz title.');
      return;
    }

    if (questions.length === 0) {
      alert('Please add at least one question.');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Save the quiz first
      const { data: quizData, error: quizError } = await supabase
        .from('quizzes')
        .insert({
          name: quizTitle,
          topic_id: topic,
          created_by: userId,
        })
        .select('id')
        .single();

      if (quizError) {
        throw quizError;
      }

      const quizId = quizData.id;

      // Save questions and answers
      for (const question of questions) {
        const { data: questionData, error: questionError } = await supabase
          .from('questions')
          .insert({
            quiz_id: quizId,
            text: question.text,
            type: question.type,
            order_index: questions.indexOf(question) + 1,
          })
          .select('id')
          .single();

        if (questionError) {
          throw questionError;
        }

        const questionId = questionData.id;

        for (const [index, option] of question.options.entries()) {
          const { error: answerError } = await supabase.from('answers').insert({
            question_id: questionId,
            text: option,
            is_correct: index === 0, // Assume the first option is correct for simplicity
            order_index: index + 1,
          });

          if (answerError) {
            throw answerError;
          }
        }
      }

      alert('Quiz, questions, and answers saved successfully!');
      router.push(`/quiz/${subject}/${topic}`);
    } catch (err) {
      console.error('Error saving quiz, questions, or answers:', err);
      setError('An error occurred while saving the quiz.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <Header />
      <main className="container py-8">
        <div className="max-w-2xl mx-auto">
          <h1 className="text-2xl font-bold mb-4">Create a New Quiz</h1>
          <div className="formField">
            <label htmlFor="quizTitle">Quiz Title</label>
            <input
              type="text"
              id="quizTitle"
              value={quizTitle}
              onChange={(e) => setQuizTitle(e.target.value)}
              readOnly
            />
          </div>
          {questions.map((question, index) => (
            <div key={question.id} className="formField">
              <label htmlFor={`question-${index}`}>Question {index + 1}</label>
              <input
                type="text"
                id={`question-${index}`}
                placeholder="Enter question text"
                value={question.text}
                onChange={(e) =>
                  handleQuestionChange(question.id, { text: e.target.value })
                }
              />
              <label htmlFor={`type-${index}`}>Answer Type</label>
              <select
                id={`type-${index}`}
                value={question.type}
                onChange={(e) =>
                  handleQuestionChange(question.id, {
                    type: e.target.value as 'radio' | 'checkbox',
                  })
                }
              >
                <option value="radio">Radio</option>
                <option value="checkbox">Checkbox</option>
              </select>
              {['radio', 'checkbox'].includes(question.type) && (
                <div className="formField">
                  <label>Options</label>
                  {question.options.map((option, optionIndex) => (
                    <div key={optionIndex} className="flex items-center gap-2">
                      <input
                        type="text"
                        placeholder={`Option ${optionIndex + 1}`}
                        value={option}
                        onChange={(e) =>
                          handleOptionChange(
                            question.id,
                            optionIndex,
                            e.target.value
                          )
                        }
                      />
                      <button
                        type="button"
                        onClick={() =>
                          setQuestions((prev) =>
                            prev.map((q) =>
                              q.id === question.id
                                ? {
                                    ...q,
                                    options: q.options.filter(
                                      (_, idx) => idx !== optionIndex
                                    ),
                                  }
                                : q
                            )
                          )
                        }
                        className="create-quiz-btn"
                      >
                        Delete Option
                      </button>
                    </div>
                  ))}
                  <button
                    type="button"
                    onClick={() => handleAddOption(question.id)}
                    className="create-quiz-btn"
                  >
                    Add Option
                  </button>
                </div>
              )}
              <button
                type="button"
                onClick={() => deleteQuestion(question.id)}
                className="create-quiz-btn mt-4"
              >
                Delete Question
              </button>
            </div>
          ))}
          <button onClick={addQuestion} className="create-quiz-btn mb-4">
            Add Question
          </button>
          {error && <p className="text-error">{error}</p>}
          <button
            onClick={handleCreateQuiz}
            disabled={loading}
            className="create-quiz-btn w-full mt-4 disabled:opacity-50"
          >
            {loading ? 'Creating...' : 'Create Quiz'}
          </button>
          <button
            onClick={handleSaveQuestionsAndAnswers}
            disabled={loading}
            className="create-quiz-btn w-full mt-4 disabled:opacity-50"
          >
            {loading ? 'Saving...' : 'Save Quiz'}
          </button>
        </div>
      </main>
      <Footer />
    </>
  );
}
